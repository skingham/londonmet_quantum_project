\section{A: Unit Details}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Quantum Foundations and Hardware}

We present an introduction to the field of quantum computing. 
We do this by setting out the historic origins and the fundamental concepts that distinguish it from classical computation.
The unit introduces qubits and quantum gates, and looks briefly at the physical systems used to realise them.
We aim to build in intuition and background to build the mathematical formalism introduced in subsequent units.

A gentle introduction seeks to highlight why quantum computation is special.
By understanding a little about how we create quantum particles and exotic quantum states, 
the student should feel more confident in the more abstract concepts introduced as the unit progresses.

Learners need a shared vocabulary (qubits, gates and physical realisations) before they can tackle algorithms or cryptographic threats. 
A brief historical sketch and a tour of today's hardware ground the abstract mathematics that follows.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Quantum Computing History}

\emph{Purpose}: show that quantum computing arose from the practical question raised by Feynman,  "how do we simulate quantum physics?", 
and evolved through Deutsch to modern NISQ devices.

\emph{Key message}: classical computers struggle to model quantum systems; quantum hardware was conceived to close that gap.

\emph{Outcomes}:
\begin{itemize}
	\item \emph{Explain} Feynman's simulation argument and its significance for quantum computation.
\end{itemize}

This unit draws on Preskill's paper \citetitle{Preskill:2023} \cite{Preskill:2023} (2023)
and Feynman's \citetitle{Feynman:1986} (1986) \cite{Feynman:1986}, 
to provide a historical context and initial motivation for quantum computing.

Feynman introduces intuitively why quantum systems cannot be simulated efficiently by classical computers.
He does this through the description of analogue simulation of physical quantum systems, 
and so allows the student so see the contrast with digital quantum information processing with qubits and gates.
A discussion on Deutsch's contributions - \citetitle{Deutsch:1985} \cite{Deutsch:1985} (1985) - offers context on this.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{The Qubit: Representations and Realizations}

\emph{Purpose}: define the qubit as a two-level quantum system and introduce the vector/Bloch-sphere picture.

\emph{Key message}: superposition, no-cloning and entanglement distinguish qubits from bits, 
yet all can be expressed in familiar linear-algebra terms. 
Higher-level qudits exist but do not expand computational power beyond the qubit abstraction.

\emph{Outcomes}:
\begin{itemize}
	\item \emph{Contrast} classical and quantum computing using the state-space (exponential) argument.
\end{itemize}

We introduced the qubit by talking about two-level quantum systems.
Using examples of photons, trapped ions, quantum dots, superconducting quantum systems, 
introduce the \emph{vector-state} representation and \emph{bloch-spheres}.
Whilst talking about quantum states, we can introduce \emph{qudits}, such as \emph{qutrits} and \emph{quarts}.
Drawing from $q$-ary linear code, we demonstrate the higher cardinality of three- and four-level quantum systems,
and show that there is no loss in expressiveness in using the qubit abstraction.

Introduce concepts of \emph{superposition}, \emph{no-cloning} and \emph{entanglement} in one and two qubit systems.
Through this, introduce the \emph{Dirac} notation along side \emph{binary strings} and \emph{vector notation}
as representations of superposition and entangled states.
Use vector spaces and bloch spheres as a natural way of understanding a single qubit system.
Measurement of computational basis states are discussed.

We can use the introduction, and a high level, to demonstrate how quantum phenomenon can be manifested through physical systems.
This can be as simple as using a set of polarising filters to see the ?? paradox.  
The setup for photons to describe entanglement is straight forward, 
but we can describe technique for ions and highlight how experimental physics is moving the industry forward 
by reading \href{http://scienceblogs.com/principles/2009/07/07/entanglement-by-accident/}{Monroe on accidental ion entanglement}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Quantum Machinery}

\emph{Purpose}: orient students within the hardware landscape; analogue simulators, annealers, photonic devices and gate-based processors.

\emph{Key message}: different technologies excel in different niches 
(e.g. photonics for communications, superconducting qubits for general algorithms), 
and noise considerations motivate the distinction between NISQ and future fault-tolerant machines.

\emph{Outcomes}:
\begin{itemize}
	\item \emph{Identify} the major hardware platforms and discuss their practical trade-offs.
	\item \emph{Describe} at least one experimental set-up that manifests superposition or entanglement (e.g. polarised photons).
\end{itemize}

Give examples of the major categories of quantum computing:
\begin{itemize}
	\item Analogue Quantum Simulators; specialised setups to gain insights into strongly correlated matter (condensed-matter models, spin states).
	\item Analogue QUBO annealers, such as D-Wave: Fixed Ising form solvers with flexibility over in scalar parameters.
	\item Digital photonics, such as PsiQuantum: single-photon and time-bin approaches, uses in communications.
	\item Digital gate based systems: typically super-conducting and trapped-ions technologies for general computing applications.
\end{itemize}

Examples of where natural advantages of certain technologies, such as photonics for quantum communication 
and quantum cryptography and key distribution can be discussed.

Photonics poses interesting challenges and opportunities. 
Is both one of the earliest \emph{cite{photonics}} practical quantum technologies 
and an expensive one to set up research for \emph{cite{photonics:costs-of-research}}. 
Yet it has easily demonstrates a number of quantum principles in a way which is easily explainable at an under-graduate science level.
Early \emph{Quantum Key Distribution (QKD)}  \index{Quantum Key Distribution} used quantum properties of photons, 
specifically photon polarisation - which can be demonstrated with polarised sunglasses - to develop the delivery of one-time pads 
for secure communications.

Further, the exposition of the QKD of randomly generated one time pads highlights another recent development
where quantum randomness was demonstrated for the first time recently, using digital quantum computers and RCS
[\href{https://scitechdaily.com/a-56-qubit-quantum-computer-just-did-what-no-supercomputer-can/}{google jpm 56 qubit QRNG}].

Looking at the physical implementation of quantum systems, we will see certain advantages of different quantum particles
with respect to  \emph{noise}, \emph{decoherence} and \emph{gate fidelity}.
This brings into scope the topics of near-term \emph{NISQ} vs the holy-grail of \emph{FTQC}, 
laying the ground work for the introduction of quantum error correction schemes.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Quantum Computation, Gates and Circuits}

This unit presents the foundational mathematical skill sets needed to describe and apply gates to effect computations. 
Students now translate the physical intuition from Unit 1 into the mathematical grammar of quantum computing
(linear algebra, postulates, gates and simple circuits) so that every later algorithmic idea has a precise formal scaffold.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Linear Algebra}

\emph{Purpose}: supply the indispensable toolkit of vector spaces, inner products, matrix operators and tensor products,
and using the qubit as a running example.

\emph{Outcomes}:
\begin{itemize}
	\item Express single- and multi-qubit states as column vectors.
	\item Identify Hermitian, unitary and Pauli operators and explain why unitarity $\iff$ reversibility.
	\item Compute simple tensor products and eigen-decompositions with pen-and-paper and NumPy.
	\item \emph{Represent} quantum states in bra-ket, column-vectors, Bloch-sphere co-ordinates form.
\end{itemize}

We start by recapping single- and dual-qubit vector states, 
and give the generalization of \emph{quantum registers} used in quantum computing. 

\begin{itemize}
	\item Bases and linear independence
	\item Linear Operators as Matrices
	\item Pauli Matrices
	\item Interproducts
	\item Eigenvectors and eigenvalues
	\item Adjoints and Hermitian Operatorss:  $U^{\dagger}$ is both the inverse and the transpose-conjugate; multiplying restores  the identity. 
	\item Tensor Products
	\item Operator functions
	\item Commutator and anti-commutator
	\item Polar and singular value decompositions
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Quantum Postulates}

\emph{Purpose}: anchor the algebra to the four standard postulates, 
emphasising Postulates 2 and 3 as the dynamical core and Postulate 4 as the blueprint for composite systems.

\emph{Outcomes}:
\begin{itemize}
	\item State each postulate in one sentence.
	\item Explain how unitary time evolution and projective measurement coexist.
	\item Give a short explanation of why the Toffoli gate is the reversible AND analogue.
	\item \emph{Explain} the four quantum postulates and illustrate each with a direct example.
\end{itemize}

	Most modern texts (e.g., Nielsen \& Chuang) frame non-relativistic quantum mechanics around four core postulates. 
	Two describe \textbf{states} and \textbf{composite systems}, 
	while the other two govern \textbf{dynamics} on how a state changes with time or under measurement.

\emph{Foundational Postulates}
\begin{itemize}
	\item \textbf{Postulate 1:} A quantum state is a vector in Hilbert space.
	\item \textbf{Postulate 4:} Composite systems are described by the tensor product of individual system spaces.
\end{itemize}

These two postulates set the stage, but they do not directly govern dynamical evolution.

\emph{Postulates Governing Dynamics}
	\begin{table}[h]
		\centering
		\renewcommand{\arraystretch}{1.2}
		\begin{tabular}{|c|l|l|l|}
			\hline
			\textbf{\#} & \textbf{Postulate} & \textbf{What it says} & \textbf{Why it's “dynamics”} \\
			\hline
			\textbf{2. Unitary Time Evolution} & If a system is isolated during the interval \( t_0 \to t \), its state vector evolves by a \textbf{unitary} operator \( U(t,t_0) \). In the Schrödinger picture: & \( U(t,t_0) = \exp\!\bigl[-\,iH(t-t_0)/\hbar\bigr] \), where \( H \) is the system's Hermitian Hamiltonian. & This gives the reversible, deterministic law (Schrödinger equation) for how amplitudes flow, analogous to Newton's laws for classical trajectories. \\
			\hline
			\textbf{3. Measurement (Projective Version)} & Measuring an observable \( M \) with eigenvalues \( \{m_k\} \) and projectors \( \{P_k\} \) produces outcome \( m_k \) with probability \( p_k=\langle\psi|P_k|\psi\rangle \). After measurement, the system jumps to: & \( P_k|\psi\rangle/\sqrt{p_k} \). & This is the \textbf{non-unitary} dynamical rule that accounts for interaction with a detector and explains why we observe definite outcomes despite quantum interference. \\
			\hline
		\end{tabular}
		\caption{Postulates governing dynamics in quantum mechanics}
	\end{table}

\emph{Summary}
Postulate 2 provides the continuous, reversible evolution between measurements, while Postulate 3 supplies the stochastic, irreversible update during measurement. Together, they form the complete dynamical framework of standard quantum theory.

\emph{Classical irreversible gates}: 
\begin{itemize}
	\item Show truth table of AND. Ask: can you recover the inputs from the output? No! Information is lost.
	\item Introduce the Toffoli gate (adds a third control bit to keep reversibility).
\end{itemize}

\emph{Qubit and unitarity rule}:
\begin{itemize}
	\item Define qubit $|psi\rangle = \alpha |0\rangle + \beta |1\rangle⟩$.
\item State "Quantum mechanics says evolution is linear and norm-preserving $\Rightarrow$ matrices must be unitary."
\end{itemize}

\emph{Unitary $\iff$ reversible}:
\begin{itemize}
	\item Prove quickly: $U^\dag$ is both the inverse and the transpose-conjugate; multiplying restores the identity.
\end{itemize}

\emph{Circuit as factorisation}
\begin{itemize}
	\item Stack three 2×2 matrices; note the product is still unitary.
	\item Draw the same gates in reverse order with daggers = inverse circuit.
\end{itemize}

\emph{Non-unitary aspirations}:
\begin{itemize}
	\item "We want to multiply by a real-valued data matrix or Hamiltonian; those aren't unitary!"
\end{itemize}

\emph{Block-encoding mechanics}:
\begin{itemize}
	\item Add one ancilla qubit initialised to $|0\rangle$.
	\item Show that controlling on the ancilla embeds $A/\alpha$ in the top-left corner of the full matrix.
	\item Stress the scaling factor αα and the success-probability interpretation.
\end{itemize}

\emph{Why:}
\begin{itemize}
	\item Mention HHL, QSVT, quantum kernels: "All call a block-encoding as a subroutine."
	\item End with the mantra: "Circuits implement unitaries; block-encodings let those unitaries secretly carry the matrices we care about."
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\emph{Why Irreversibility shows up in practice}
\begin{enumerate}
	\item Measurement - Projective measurement applies a non-unitary "collapse" operator. 
	Information about the phase relations among amplitudes is discarded, so you cannot un-measure a generic outcome.

	\item Open systems / decoherence - Coupling to an environment causes the joint evolution (system + bath) to stay unitary, 
	but the reduced state of the system alone evolves under a completely-positive trace-preserving (CPTP) map, 
	which is generally not invertible. 
	Apparent irreversibility is just the price of ignoring the environment's qubits.
\end{enumerate}

\emph{Superdense Coding}
\begin{itemize}
	\item Bell states and EPR
\end{itemize}

\emph{Density Operator}

\emph{Schmidt decomposition and purifications}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Basic Gates \& Operations}

\emph{Purpose}: expound on the universal gate set and develop the circuit picture.

\emph{Outcomes}:
\begin{itemize}
	\item Build a three-gate circuit (e.g. H–CNOT–Z) and predict output probabilities.
	\item Describe the no-cloning theorem's impact on quantum communications.
	\item Run a simple circuit in Qiskit or Cirq and verify results against theory.
	\item \emph{Apply} single- and two-qubit unitary gates and compute resulting state vectors.
\end{itemize}

\textbf{Concepts Covered}:
\begin{itemize}
	\item Bra-ket notation and state representation; a way of writing vectors in a 2-D vector space: $|v \rangle \in \mathbb{C}^2$
	\index{Bra-ket Notation}
	\item Matrix transformations of quantum states and gates
	\item Basic gates: Pauli (X, Y, Z), Hadamard (H), CNOT, Phase shifts, and controlled gates
	\item Principle of reversibility: quantum operations as unitary transformations, implications for circuit construction, contrast to classical irreversibility.
	\item No-Cloning theorem: proofs and intuitive reasoning, consequences for quantum communication and cryptography.
\end{itemize}


\textbf{Workshops}:
\begin{itemize}	
	\item IBM Qiskit (core gate library, interactive circuit composer)
	\item Google Cirq (custom gate implementation, visualizations)
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Tensor Mathematics and Circuit Composition}

\emph{Purpose}: show how small gates scale to multi-qubit registers via tensor products and controlled operations.

\emph{Learning}:
\begin{itemize}
	\item Rewrite a controlled-U gate as a block matrix.
	\item Decompose a two-qubit gate into single-qubit rotations and CNOTs (by lookup or SDK).
	\item \emph{Assemble} and run a short circuit on a cloud simulator, interpreting the measurement statistics.
\end{itemize}

\textbf{Workshop SDKs/Platforms}:
\begin{itemize}
	\item IBM Qiskit Composer (interactive drag-and-drop circuit composer)
	\item Google Cirq tutorials (introductory lab exercises)
	\item Julia QML/Yao.jl; automatic differentiation (fast simulations, tensor-network circuits, tensor operations)
	\item Pennylane: automatic differentiation  (tensor circuit building, differentiable programming)
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{NISQ Devices and Error Correction Codes}

\emph{Purpose}: connect the perfect matrix circuit model to noisy hardware and introduce the idea of logical (encoded) qubits.

\emph{Outcomes}:
\begin{itemize}
	\item Simulate a bit-flip error and show how a three-qubit repetition code detects it.
	\item Articulate the difference between NISQ error-mitigation and full fault tolerance.
	\item \emph{Demonstrate} how a simple error-correction code protects against a single-qubit error.	
	\item \emph{Discuss} the practical trade-offs of state preparation on-chip versus hybrid classical–quantum approaches in the NISQ era.
\end{itemize}


We recap the NISQ devices introduction from Preskill and look at error correction.
We describe the use of logical qubits constructed from physical qubits. 
We follow this will quantum error correction to demonstrate theoretical and practical solutions to noise and decoherence.
Surface and colour stabiliser codes can be explained diagrammatically (hence topological protection),
 and as well as demonstrating on paper how single phase-flip and bit flip errors can be caught an corrected, 
 we can demonstrate this using SDKs.

\textbf{Workshop SDKs/Platforms}:
\begin{itemize}
	\item IBM Quantum Experience (real-device demonstrations, noise simulations)
	\item Google Cirq (customizable noise models)
	\item IBM Qiskit Noise Simulator (interactive noise examples)
	\item IBM Qiskit Ignis (specialized quantum error correction toolkit)
	\item Google Cirq (topological code simulations, custom circuit design)
	\item (Additional tool): Stim (Google's specialized quantum error correction simulator)
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Quantum Algorithms and Classical Cryptography}

Students now see why quantum computing matters to cryptography:
a handful of core algorithms, most famously Shor's and Grover's, break or undermine real-world protocols. 
This cements the linear-algebra skills from Unit 2 and prepares students for the algorithmic blocks used in Unit 4.

Use Shor's original paper as a motivating example for the ideas that were perfected subsequent to his paper:
\begin{itemize}
	\item Period finding as Quantum algorithm
	\item Modular arithmetic as state preparation
	\item Quantum phase estimation for modular multiplication and exponentiation 
	\item Hidden Subgroup Problem in terms a eigenvalue (or phase) of a unitary operator
	\item The unitary as an Oracle-like Component
	\item Amplitude Amplification
\end{itemize}

We then look at some subsequent algorithms that developed these ideas, building confidence with circuit complexity in preparation for more
complex building blocks and algorithms in unit-4.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Classical Cryptography Problems}

\emph{Purpose}: Review the number theory tasks (factorisation, discrete logs, subset-sum) 
that underpin certain cryptographic protocols, so that the impact of quantum-speed-ups is clear.

Understand the mathematical underpinnings of hidden-subgroup problems, and their broader application.

\emph{Outcomes}:
\begin{itemize}
	\item \emph{Explain} how Shor's and Grover's algorithms threaten current public-key and symmetric schemes.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Deutsch–Jozsa and Simon's Algorithms}

\emph{Purpose}: introduce the hidden-subgroup paradigm in its simplest forms; 
students practise reading small circuits and interpreting their algebraic output.


\emph{Outcomes}:
\begin{itemize}
	\item \emph{Demonstrate} core building block oracle
	\item \emph{Discuss} the practical trade-offs of state preparation on-chip versus hybrid classical–quantum approaches in the NISQ era.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Grover's Algorithm}

\emph{Purpose}: contrast \emph{amplitude-amplification} (AA) speed-ups with exponential ones; 
reinforce oracles, reflection operators and the role of noise in NISQ devices.

\emph{Outcomes}:
\begin{itemize}
	\item \emph{Implement} Oracles as unitary transforms and integrate with Grover Operator.
\end{itemize}

We present a Grover notebook using IBM QISKIT to demonstrate building the unitary Oracle
and running this with the built in \emph{Grover Operator}.

We take the opportunity to use noisy backend simulators to observer the effects of noise.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Quantum Phase Estimation (QPE) and modular arithmetic}

\emph{Purpose}: show that QPE is the work-horse subroutine behind Shor and many later algorithms; 
modular multiplication provides the concrete oracle.

\emph{Outcomes}:
\begin{itemize}
	\item \emph{Demonstrate} core building block QPE
	\item Describe intuitively the problems of state preparation
\end{itemize}

\textbf{Workshop SDKs/Platforms}:
\begin{itemize}
	\item IBM Qiskit (QFT tutorials, modular exponentiation implementations)
	\item Pennylane (QFT example notebooks)
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Quantum Fourier Transform (QFT)}

\emph{Purpose}: link the Fourier basis to period-finding 
and demonstrate a compact circuit that students can simulate.

\emph{Outcomes}:
\begin{itemize}
	\item \emph{Demonstrate} core building block QFT and Fourier basis using qubit representations.
	\item Build circuits to perform transform and arithmetic.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Putting it all Together with Shor's Algorithm}

\emph{Purpose}: assemble the earlier blocks 
(state preparation, modular arithmetic, QFT)
into the complete quantum attack on RSA.

\emph{Outcomes}:
\begin{itemize}
	\item \emph{Implement} a small instance of Shor's or Grover's algorithm on a simulator and interpret the results.
\end{itemize}

\textbf{Workshop SDKs/Platforms}:
\begin{itemize}
	\item IBM Qiskit (detailed practical implementations, interactive tutorials)
	\item Pennylane (modular arithmetic circuits)
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Advanced Quantum Algorithms}

Having mastered core algorithms, students now meet the techniques that dominate current research
(matrix inversion, polynomial singular-value transforms, quantum optimisation and hybrid workflows)
so they can read, reproduce and extend state-of-the-art results:

\subsubsection*{Quantum Matrix Inversion (with HHL)}

\emph{Purpose}: show how a quantum computer can invert a sparse, well-conditioned matrix
exponentially faster than classical algorithms, subject to data-loading and read-out caveats.

The Harrow-Hassidim-Lloyd (HHL) \cite{Harrow:2009} \cite{Lipton:2021} algorithm is an important piece of work, 
designed to solve the Quantum Linear System Problem (QLSP). 
QLSP can be understood by considering the classical Linear System Problem (LPS) where we seek a vector $x$
to satisfy the set of linear equations $Ax = b$.  QLSP takes  a sparse, well-conditioned matrix  $A$ 
and vector $b$, encoded as quantum states, and produces a quantum state $\lvert x\rangle$ as a solution.  
Solving this problem requires a quantum matrix inversion, which HHL provides.

This algorithm, although seminal, leaves a number of challenges to overcome before the quantum speed-up of the 
matrix inversion can be taken advantage of.  The first is that recovering the full classical description of the 
vector $x$ from the quantum state can be computationally expensive and add significant overhead.

The second we raise is the problem of \emph{Quantum Random Access Memory} (QRAM) 
and practical issues in providing fast QRAM and loading large amounts of classical data.  
This subject comes up in another advanced technique, block encoding.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Block Encoding \& Quantum Singular-Value Transformation (QSVT)}

\emph{Purpose}: present block encoding as the universal trick for hiding non-unitary matrices inside unitaries, 
and QSVT as the "polynomial filter" that subsumes Grover, Hamiltonian simulation and HHL.

We take a high-level approach to QSVT as it is mathematically challenging to present, involving Chebyshev polynomials,
quantum signal processing and a good amount of linear-algebra bookkeeping.

The core idea \emph{Block-Encoding} (BE) is that, if you can hide a non-unitary matrix $A$ inside of a matrix 
This core technique of BE comes up a lot in modern quantum algorithms, and it should be presented.  
Building on the concepts from Grover's AA, QPE, and Hamiltonian simulation, we present the motivation 
and the pattern of the solution.  
Indeed, the analogy of the QSVT as a digital filter acting on frequency components, should bolster earlier work with phases.

\emph{Outcome}:
\begin{itemize}
	\item Understand QSVT as polynomial singular-value transformations via controlled phase sequences.
	\item Identify Grover and Hamiltonian simulation as special cases.
	\item Describe an \emph{unitary control register} as block-encoding \emph{plus} an ancilla qubit.
	\item Run a prepared QSVT circuit on a toy, low-degree, matrix and verify the singular values.
\end{itemize} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Quantum Annealing \& QUBO (D-Wave)}

We introduce Ising and Quantum Unconstrained Binary Optimization (QUBO) models for quantum annealing.  
Problems that are typically tackled with theses models are discussed, 
principally optimisation problems, Hamiltonians, and energy landscapes of quantum chemistry.

\begin{itemize}
	\item Demonstrates hardware tailored to Ising/optimization problems and contrasts analogue with gate-model approaches.
 	\item D-Wave Leap (Quantum annealing experiments, practical QUBO solutions)
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Gate-model Optimisation (QAOA / VQE)}

\emph{Purpose}: the current focus has shifted towards heuristic algorithms, inspired by classical principles and quantum phenomena, 
like the \emph{Quantum Approximate Optimization Algorithm} (QAOA) and \emph{Variational Quantum Eigensolver} (VQE).
These heuristic methods are designed for NISQ devices, and lack provable guarantees but hold promise for practical applications.

\begin{itemize}
	\item Shows how variational circuits tackle the same problems on NISQ gate-based devices.
\end{itemize}

\textbf{Workshop SDKs/Platforms}:
\begin{itemize}
	\item Pennylane (variational quantum algorithms for optimization)
	\item Google Cirq (QAOA tutorials)
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Quantum Algorithms for Graph Problems}

Concrete optimization tasks (Max-Cut, colouring) that map neatly to both annealing and QAOA.

\emph{}
\begin{itemize}
	\item Graph coloring
	\item max-cut
	\item shortest path problems
\end{itemize}

\textbf{Workshop SDKs/Platforms}:
\begin{itemize}
	\item Google Cirq (QAOA for MaxCut, detailed graph problems examples)
	\item D-Wave Leap (Ising models, graph optimization problems)
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{QSVM}

\emph{Outcomes}:
\begin{itemize}
	\item \emph{Implement} a simple quantum kernel OC-SVM on a cloud platform and benchmark against a classical baseline.
\end{itemize}

\emph{ML Primer}
\begin{itemize}
	\item Kernels
	\item SVM math
	\item Anomaly-detection metrics
\end{itemize}

\emph{Quantum Kernels \& Feature Maps}
\begin{itemize}
	\item Swap-test
	\item Fidelity estimation
	\item Expressivity vs noise
\end{itemize}

\emph{Quantum OC-SVM Workflow}
\begin{itemize}
	\item Data-encoding circuits
	\item Kernel-matrix build on hardware (QVM or real)
	\item Classical QP (CVXOPT / LIBSVM) for support vectors
	\item Hybrid inference loop; noise-mitigation hacks
\end{itemize}


\emph{Workshop SDKs/Platforms}
\begin{itemize}
	\item Pennylane (best QSVM wrappers)
	\item Julia QML for high-performance simulations
	\item Implement OC-SVM in Pennylane
	\item Test against classical scikit-learn
\end{itemize}


\subsubsection*{Variational Classifiers}

\textbf{Workshop SDKs/Platforms}:
\begin{itemize}
	\item Pennylane (core QML package, variational circuits)
	\item Julia QML/Yao tutorials (high-performance QML simulations)
\end{itemize}

\subsubsection*{Quantum Neural Nets}
\begin{itemize}
	\item Pennylane (smooth classical-to-quantum transition tutorials, quantum neural nets)
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Hybrid Classical-Quantum Systems}

\emph{Purpose}: teach students to treat the QPU as a remote accelerator within 
a larger data pipeline, mirroring how real projects are executed in the NISQ era.

Unit treats a quantum device as a remote accelerator via hybid-jobs api.
Exercises reinforce core quantum ideas; state preparation, measurement statistics, error mitigation.

The analogy: similarly to GPU or ML cloud resources (PyTorch, AWS SageMaker) 
quantum processes are an external call from the Python code to accelerate 
an specific loop, while local processing handles the data wrangling, optimisation, logging, etc.

\begin{itemize}
	\item rationale behind the use of hybrid classical-quantum computing in the NISQ era
	\item Swap test; measurement statistics
	\item Error mitigation
	\item error budgets
	\item Parameter-shift rule; unitarity	
\end{itemize}

\emph{diagram: loop of [ ETL/Feature engineer -> circuit generation/SDK -> Quantum execution (QPU/sim)]}

\textbf{Topics}
\begin{itemize}
	\item Kernel estimation: OC-SVM kernel loop
	\item Variational Quantum Algorithms (VQAs) workflows: 
	Frame VQAs (like QAOA or VQE) as prime examples of the hybrid paradigm, 
	highlighting the classical optimisation loop and the quantum circuit execution/measurement step; 
	VQE or QAOA on Braket Hybrid Jobs; 
	\item Data pipeline walk through ETL-to-QPU pipeline
\end{itemize}

\emph{Outcomes}:
\begin{itemize}
	\item Architect a pipeline that ingests classical time-series, invokes a quantum kernel routine, and performs classical optimisation.
	\item Quantify shot noise and latency, choosing batch sizes and iteration counts that respect cloud-QPU quotas.
	\item Deploy a simple hybrid job on either AWS Braket or IBM
	\item Classic/Quantum performance 
	\item TensorFlow Quantum (Cirq-based, optional for broader ML integrations)
	\item Julia Quantum ML/QML.jl (efficient QML experiments, classical-quantum hybrid models)
	\item \emph{Architect} a hybrid workflow that balances shot cost, latency and classical compute.
\end{itemize}